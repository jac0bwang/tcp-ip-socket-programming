理解TCP和UDP
============

TCP/IP协议栈
------------
![](https://github.com/jac0bwang/tcp-ip-socket-programming/blob/master/ch04/tcp_udp.png)
## 链路层
> 链路层是物理连接领域标准化的结果。若两台主机通过网络进行数据交换，
> 则需要路由器之间的连接，链路层就负责这些标准。
## IP层(网络层)
> IP层是为了解决在复杂网络中进行数据传输，进行路径选择的问题。
> 由于每次传输数据的路径选择不一致，所以当数据发生错误时无法解决，
> 因此IP协议无法应对数据错误。
## TCP/UDP层(传输层)
> TCP和UDP以IP层提供的路径信息为基础，进行实际的数据传输，
> 故该层又称为**传输层**。TCP传输数据过程中，对方收到数据包后会
> 回复确认数据包，如果超时没有回复确认数据包则会超时重传。
## 应用层
> 上述内容是套接字通信过程中自动处理的。选择数据路径和数据
> 确认过程都是隐藏到套接字内部。应用层协议就是根据程序特点
> 制定客户端和服务端的通信规则，网络编程的大部分内容就是设计并实现应用层协议。

实现基于TCP的服务器端/客户端
============================

## 进入等待连接请求状态
```
#include<sys/socket.h>

int listen(int sock, int backlog);
//成功时返回０，失败时返回-1
```
- sock:希望进入等待连接请求状态的套接字，该套接字成为服务端套接字
- backlog:连接请求等待队列的长度，若为５则表示最多有五个连接请求进入等待队列
## 受理客户端连接请求
```
#include<sys/socket.h>

int accept(int sock, struct sockaddr* addr, socklen_t* addrlen);
//成功时返回创建的套接字，失败时返回-1
```
## 客户端发起连接请求
```
int connect(int sock, struct sockaddr* addr, socklen_t* addrlen);
//成功时返回0，失败时返回-1
```
> 客户端调用connect函数后只有在以下情况之一才会返回：<br>
- 服务端接受连接请求
- 发生网络中断等异常情况
所谓的**接收连接**并不意味着服务器端调用**accept**函数，其实是服务器端把连接请求信息
记录到等待队列。因此**connect**函数返回后并不立即进行数据交换

客户端分配套接字地址 （服务器端 bind函数功能）
--------------------
客户端的IP地址和端口在调用connect函数时自动分配
- 何时？ 条用 **connect**函数时
- 何地？ 操作系统，更准确是内核中
- 如何？ IP用计算机的IP，端口随机


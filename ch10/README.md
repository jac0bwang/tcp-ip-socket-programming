1. 进程概念及应用
=================
	
## 两种类型的服务器端
- 顺序 处理连接请求的受理时间
- 并发 处理连接请求的受理时间

## 并发服务器端的实现方法
- 多进程服务器 ： 通过创建多个进程提供服务
- 多路复用服务器 : 通过绑定并统一管理I/O对象提供服务
- 多线程服务器 ： 通过生成与客户端等量的线程提供服务

## 理解进程

**进程** ： 占用内存空间的正在运行的程序

### CPU核的个数与进程数

## 进程 ID

## 通过调用fork函数创建进程
```
#include <unistd.h>

pid_t fork();//成功时返回进程ID，失败时返回-1
```
- 父进程：返回子进程ID <br>
- 子进程：返回0

2. 进程与僵尸进程
=================

## 僵尸(Zombie)进程
进程完成工作后应该被销毁，如果未被销毁将成为僵尸进程，占用系统资源，这种状态下的进程就是**僵尸进程**

## 产生僵尸进程的原因
如下 2 个示例展示调用fork函数产生子进程的终止方式：
- 传递参数并调用 exit 函数
- main 函数中执行 return 语句并返回值
而这些值都会传递给操作系统，操作系统不会销毁子进程，直到把这些值传递给产生子进程的父进程

应该向创建子进程的父进程传递**子进程**的**exit参数值**或**return语句的返回值**

如何向父进程传递这些值？
> 操作系统不会主动传递给父进程，只有父进程主动发起请求（系统调用）

## **销毁僵尸进程1**：利用wait函数
为了销毁子进程，父进程主动请求获取子进程的返回值，共有2中发方法
```
#include <sys/wait.h>

pid_t wait(int* status);//成功时返回子进程ID，失败时返回-1
```
- **WIFEXITED(status)** : 子进程正常终止时返回true
- **WEXITSTATUS(status)** : 返回子进程的返回值

## **销毁僵尸进程2**：使用waitpid函数
wait 函数会引起程序阻塞，还可以考虑调用 waitpid 函数，防止阻塞的方法
```
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int* status, int option);
//成功时返回子进程ID或0,失败时返回-1
```
- pid: 目标子进程id，若传递-1,则与wait函数相同，可以等待任意子进程终止
- option: 传递常量WNOHANG，即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出

3. 信号处理
===========
已经知道子进程创建及销毁的方法，还有一个问题没解决：
```
子进程究竟何时终止？ 调用waitpid 函数后要无休止的等待吗？
```
## 向操作系统求助
子进程终止的识别主体是操作系统，让操作系统告诉父进程，他创建的子进程终止了。
这是 **信号处理(Signal Handing)**机制

## 信号与signal函数
```
#include <signal.h>

void (*signal(int signo, void(*func)(int)))(int);
// 为了在产生信号时调用，返回之前注册的函数指针
```
- 函数名：signal 
- 参数：int signal, void(*func)(int) 
- 返回值：参数类型为int，返回值为void的函数指针

> 第一个参数表示特殊情况信息，第二个参数表示在该种特殊情况发生时所要调用的函数地址，下面给出部分可以在signal函数中注册的特殊情况和对应的常数。<br>

- `SIGALRM`:  已到通过调用`alarm()`函数注册的时间 
- `SIGINT`:   输入CTRL+C 
- `SIGCHILD`: 子进程终止 

```
#include <unistd.h>

unsigned int alarm(unsigned int seconds);
//返回0或以秒为单位距SIGALRM信号发生所剩时间
```
> 如果传递一个正整形参数，则经过相应时间后将产生一个SIGALRM信号。若传递0,则之前对SIGALRM信号的预约将取消。如果通过该函数预约信号后未指定对该信号的处理函数，则（通过调用`signal()`函数）终止进程，不做任何处理。 <br>

**发生信号时将唤醒由于调用 sleep 函数而进入阻塞状态的进程，进程一旦被唤醒，就不会再进入睡眠状态**

## 利用`SIGACTION`函数进行信号处理

**signal 函数在UNIX系列的不同操作系统中可能存在区别，单signaction函数完全相同**
signaction完全可以替代signal，也更稳定，实际上很少使用 signal

```
#include <signal.h>

int sigaction(int signo, const struct sigaction* act, struct sigaction* oldact);
//成功时返回0,失败时返回-1
```

- signo:  与`signal`函数相同，传递信号信息
- act:    对应第一个参数的信号处理函数信息
- oldact: 通过此参数获取之前注册的处理信号的函数指针，若不需要则传递0

```
struct sigaction
{
    void (*sa_handler)(int);
    sigset_t sa_mask;
    int sa_flag;
}
```
> 第一个参数用于指定信号的处理函数的地址，第二、三个参数用于指定信号相关的选项和特性，一般初始化为0即可。
> sigemptyset(&act.sa_mask)
## 利用信号处理技术消灭僵尸进程

子进程终止时产生 SIGCHLD 信号

4. 基于多任务的并发服务器
=========================
## 基于进程的并发服务器模型

## 通过 fork 函数复制文件描述符
调用 fork 函数复制父进程的所有资源，调用 fork函数后，要将无关的套接字文件描述符关掉

5. 分割TCP的I/O程序
===================
讨论客户端中分割I/O程序(Routine)的方法

## 分割 I/O 程序的优点
使得读写分成不同的进程，提高频繁交换数据的程序性能

